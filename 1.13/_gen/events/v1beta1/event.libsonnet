{
  local d = (import 'doc-util/main.libsonnet'),
  '#': d.pkg(name='event', url='', help='Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system.'),
  '#new': d.fn(help='new returns an instance of Event', args=[d.arg(name='name', type=d.T.string)]),
  new(name): {
    apiVersion: 'events.k8s.io/v1beta1',
    kind: 'Event'
  } + self.metadata.withName(name=name),
  '#withAction': d.fn(help='What action was taken/failed regarding to the regarding object.', args=[d.arg(name='action', type=d.T.string)]),
  withAction(action): { action: action },
  '#withDeprecatedCount': d.fn(help='Deprecated field assuring backward compatibility with core.v1 Event type', args=[d.arg(name='deprecatedCount', type=d.T.integer)]),
  withDeprecatedCount(deprecatedCount): { deprecatedCount: deprecatedCount },
  '#withDeprecatedFirstTimestamp': d.fn(help='Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.', args=[d.arg(name='deprecatedFirstTimestamp', type=d.T.string)]),
  withDeprecatedFirstTimestamp(deprecatedFirstTimestamp): { deprecatedFirstTimestamp: deprecatedFirstTimestamp },
  '#withDeprecatedLastTimestamp': d.fn(help='Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.', args=[d.arg(name='deprecatedLastTimestamp', type=d.T.string)]),
  withDeprecatedLastTimestamp(deprecatedLastTimestamp): { deprecatedLastTimestamp: deprecatedLastTimestamp },
  '#withDeprecatedSource': d.fn(help='EventSource contains information for an event.', args=[d.arg(name='deprecatedSource', type=d.T.any)]),
  withDeprecatedSource(deprecatedSource): { deprecatedSource: deprecatedSource },
  '#withEventTime': d.fn(help='MicroTime is version of Time with microsecond level precision.', args=[d.arg(name='eventTime', type=d.T.string)]),
  withEventTime(eventTime): { eventTime: eventTime },
  '#withMetadata': d.fn(help='ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.', args=[d.arg(name='metadata', type=d.T.any)]),
  withMetadata(metadata): { metadata: metadata },
  '#withNote': d.fn(help='Optional. A human-readable description of the status of this operation. Maximal length of the note is 1kB, but libraries should be prepared to handle values up to 64kB.', args=[d.arg(name='note', type=d.T.string)]),
  withNote(note): { note: note },
  '#withReason': d.fn(help='Why the action was taken.', args=[d.arg(name='reason', type=d.T.string)]),
  withReason(reason): { reason: reason },
  '#withRegarding': d.fn(help='ObjectReference contains enough information to let you inspect or modify the referred object.', args=[d.arg(name='regarding', type=d.T.any)]),
  withRegarding(regarding): { regarding: regarding },
  '#withRelated': d.fn(help='ObjectReference contains enough information to let you inspect or modify the referred object.', args=[d.arg(name='related', type=d.T.any)]),
  withRelated(related): { related: related },
  '#withReportingController': d.fn(help='Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.', args=[d.arg(name='reportingController', type=d.T.string)]),
  withReportingController(reportingController): { reportingController: reportingController },
  '#withReportingInstance': d.fn(help='ID of the controller instance, e.g. `kubelet-xyzf`.', args=[d.arg(name='reportingInstance', type=d.T.string)]),
  withReportingInstance(reportingInstance): { reportingInstance: reportingInstance },
  '#withSeries': d.fn(help='EventSeries contain information on series of events, i.e. thing that was/is happening continuously for some time.', args=[d.arg(name='series', type=d.T.any)]),
  withSeries(series): { series: series },
  '#withType': d.fn(help='Type of this event (Normal, Warning), new types could be added in the future.', args=[d.arg(name='type', type=d.T.string)]),
  withType(type): { type: type },
  '#mixin': 'ignore',
  mixin: self
}