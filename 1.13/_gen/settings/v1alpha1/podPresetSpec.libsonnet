{
  local d = (import 'doc-util/main.libsonnet'),
  '#': d.pkg(name='podPresetSpec', url='', help='PodPresetSpec is a description of a pod preset.'),
  '#withEnv': d.fn(help='Env defines the collection of EnvVar to inject into containers.', args=[d.arg(name='env', type=d.T.array)]),
  withEnv(env): { env: if std.isArray(v=env) then env else [env] },
  '#withEnvFrom': d.fn(help='EnvFrom defines the collection of EnvFromSource to inject into containers.', args=[d.arg(name='envFrom', type=d.T.array)]),
  withEnvFrom(envFrom): { envFrom: if std.isArray(v=envFrom) then envFrom else [envFrom] },
  '#withEnvFromMixin': d.fn(help='EnvFrom defines the collection of EnvFromSource to inject into containers.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envFrom', type=d.T.array)]),
  withEnvFromMixin(envFrom): { envFrom+: if std.isArray(v=envFrom) then envFrom else [envFrom] },
  '#withEnvMixin': d.fn(help='Env defines the collection of EnvVar to inject into containers.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='env', type=d.T.array)]),
  withEnvMixin(env): { env+: if std.isArray(v=env) then env else [env] },
  '#withSelector': d.fn(help='A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.', args=[d.arg(name='selector', type=d.T.any)]),
  withSelector(selector): { selector: selector },
  '#withVolumeMounts': d.fn(help='VolumeMounts defines the collection of VolumeMount to inject into containers.', args=[d.arg(name='volumeMounts', type=d.T.array)]),
  withVolumeMounts(volumeMounts): { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] },
  '#withVolumeMountsMixin': d.fn(help='VolumeMounts defines the collection of VolumeMount to inject into containers.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
  withVolumeMountsMixin(volumeMounts): { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] },
  '#withVolumes': d.fn(help='Volumes defines the collection of Volume to inject into the pod.', args=[d.arg(name='volumes', type=d.T.array)]),
  withVolumes(volumes): { volumes: if std.isArray(v=volumes) then volumes else [volumes] },
  '#withVolumesMixin': d.fn(help='Volumes defines the collection of Volume to inject into the pod.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumes', type=d.T.array)]),
  withVolumesMixin(volumes): { volumes+: if std.isArray(v=volumes) then volumes else [volumes] },
  '#mixin': 'ignore',
  mixin: self
}