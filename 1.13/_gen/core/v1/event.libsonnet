{
  local d = (import 'doc-util/main.libsonnet'),
  '#': d.pkg(name='event', url='', help='Event is a report of an event somewhere in the cluster.'),
  '#new': d.fn(help='new returns an instance of Event', args=[d.arg(name='name', type=d.T.string)]),
  new(name): {
    apiVersion: 'v1',
    kind: 'Event'
  } + self.metadata.withName(name=name),
  '#withAction': d.fn(help='What action was taken/failed regarding to the Regarding object.', args=[d.arg(name='action', type=d.T.string)]),
  withAction(action): { action: action },
  '#withCount': d.fn(help='The number of times this event has occurred.', args=[d.arg(name='count', type=d.T.integer)]),
  withCount(count): { count: count },
  '#withEventTime': d.fn(help='MicroTime is version of Time with microsecond level precision.', args=[d.arg(name='eventTime', type=d.T.string)]),
  withEventTime(eventTime): { eventTime: eventTime },
  '#withFirstTimestamp': d.fn(help='Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.', args=[d.arg(name='firstTimestamp', type=d.T.string)]),
  withFirstTimestamp(firstTimestamp): { firstTimestamp: firstTimestamp },
  '#withInvolvedObject': d.fn(help='ObjectReference contains enough information to let you inspect or modify the referred object.', args=[d.arg(name='involvedObject', type=d.T.any)]),
  withInvolvedObject(involvedObject): { involvedObject: involvedObject },
  '#withLastTimestamp': d.fn(help='Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.', args=[d.arg(name='lastTimestamp', type=d.T.string)]),
  withLastTimestamp(lastTimestamp): { lastTimestamp: lastTimestamp },
  '#withMessage': d.fn(help='A human-readable description of the status of this operation.', args=[d.arg(name='message', type=d.T.string)]),
  withMessage(message): { message: message },
  '#withMetadata': d.fn(help='ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.', args=[d.arg(name='metadata', type=d.T.any)]),
  withMetadata(metadata): { metadata: metadata },
  '#withReason': d.fn(help="This should be a short, machine understandable string that gives the reason for the transition into the object's current status.", args=[d.arg(name='reason', type=d.T.string)]),
  withReason(reason): { reason: reason },
  '#withRelated': d.fn(help='ObjectReference contains enough information to let you inspect or modify the referred object.', args=[d.arg(name='related', type=d.T.any)]),
  withRelated(related): { related: related },
  '#withReportingComponent': d.fn(help='Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.', args=[d.arg(name='reportingComponent', type=d.T.string)]),
  withReportingComponent(reportingComponent): { reportingComponent: reportingComponent },
  '#withReportingInstance': d.fn(help='ID of the controller instance, e.g. `kubelet-xyzf`.', args=[d.arg(name='reportingInstance', type=d.T.string)]),
  withReportingInstance(reportingInstance): { reportingInstance: reportingInstance },
  '#withSeries': d.fn(help='EventSeries contain information on series of events, i.e. thing that was/is happening continuously for some time.', args=[d.arg(name='series', type=d.T.any)]),
  withSeries(series): { series: series },
  '#withSource': d.fn(help='EventSource contains information for an event.', args=[d.arg(name='source', type=d.T.any)]),
  withSource(source): { source: source },
  '#withType': d.fn(help='Type of this event (Normal, Warning), new types could be added in the future', args=[d.arg(name='type', type=d.T.string)]),
  withType(type): { type: type },
  '#mixin': 'ignore',
  mixin: self
}