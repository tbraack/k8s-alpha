{
  local d = (import 'doc-util/main.libsonnet'),
  '#': d.pkg(name='nodeStatus', url='', help='NodeStatus is information about the current status of a node.'),
  '#withAddresses': d.fn(help='List of addresses reachable to the node. Queried from cloud provider, if available. More info: https://kubernetes.io/docs/concepts/nodes/node/#addresses', args=[d.arg(name='addresses', type=d.T.array)]),
  withAddresses(addresses): { addresses: if std.isArray(v=addresses) then addresses else [addresses] },
  '#withAddressesMixin': d.fn(help='List of addresses reachable to the node. Queried from cloud provider, if available. More info: https://kubernetes.io/docs/concepts/nodes/node/#addresses\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='addresses', type=d.T.array)]),
  withAddressesMixin(addresses): { addresses+: if std.isArray(v=addresses) then addresses else [addresses] },
  '#withAllocatable': d.fn(help='Allocatable represents the resources of a node that are available for scheduling. Defaults to Capacity.', args=[d.arg(name='allocatable', type=d.T.object)]),
  withAllocatable(allocatable): { allocatable: allocatable },
  '#withAllocatableMixin': d.fn(help='Allocatable represents the resources of a node that are available for scheduling. Defaults to Capacity.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='allocatable', type=d.T.object)]),
  withAllocatableMixin(allocatable): { allocatable+: allocatable },
  '#withCapacity': d.fn(help='Capacity represents the total resources of a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity', args=[d.arg(name='capacity', type=d.T.object)]),
  withCapacity(capacity): { capacity: capacity },
  '#withCapacityMixin': d.fn(help='Capacity represents the total resources of a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='capacity', type=d.T.object)]),
  withCapacityMixin(capacity): { capacity+: capacity },
  '#withConditions': d.fn(help='Conditions is an array of current observed node conditions. More info: https://kubernetes.io/docs/concepts/nodes/node/#condition', args=[d.arg(name='conditions', type=d.T.array)]),
  withConditions(conditions): { conditions: if std.isArray(v=conditions) then conditions else [conditions] },
  '#withConditionsMixin': d.fn(help='Conditions is an array of current observed node conditions. More info: https://kubernetes.io/docs/concepts/nodes/node/#condition\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='conditions', type=d.T.array)]),
  withConditionsMixin(conditions): { conditions+: if std.isArray(v=conditions) then conditions else [conditions] },
  '#withConfig': d.fn(help='NodeConfigStatus describes the status of the config assigned by Node.Spec.ConfigSource.', args=[d.arg(name='config', type=d.T.any)]),
  withConfig(config): { config: config },
  '#withDaemonEndpoints': d.fn(help='NodeDaemonEndpoints lists ports opened by daemons running on the Node.', args=[d.arg(name='daemonEndpoints', type=d.T.any)]),
  withDaemonEndpoints(daemonEndpoints): { daemonEndpoints: daemonEndpoints },
  '#withImages': d.fn(help='List of container images on this node', args=[d.arg(name='images', type=d.T.array)]),
  withImages(images): { images: if std.isArray(v=images) then images else [images] },
  '#withImagesMixin': d.fn(help='List of container images on this node\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='images', type=d.T.array)]),
  withImagesMixin(images): { images+: if std.isArray(v=images) then images else [images] },
  '#withNodeInfo': d.fn(help='NodeSystemInfo is a set of ids/uuids to uniquely identify the node.', args=[d.arg(name='nodeInfo', type=d.T.any)]),
  withNodeInfo(nodeInfo): { nodeInfo: nodeInfo },
  '#withPhase': d.fn(help='NodePhase is the recently observed lifecycle phase of the node. More info: https://kubernetes.io/docs/concepts/nodes/node/#phase The field is never populated, and now is deprecated.', args=[d.arg(name='phase', type=d.T.string)]),
  withPhase(phase): { phase: phase },
  '#withVolumesAttached': d.fn(help='List of volumes that are attached to the node.', args=[d.arg(name='volumesAttached', type=d.T.array)]),
  withVolumesAttached(volumesAttached): { volumesAttached: if std.isArray(v=volumesAttached) then volumesAttached else [volumesAttached] },
  '#withVolumesAttachedMixin': d.fn(help='List of volumes that are attached to the node.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumesAttached', type=d.T.array)]),
  withVolumesAttachedMixin(volumesAttached): { volumesAttached+: if std.isArray(v=volumesAttached) then volumesAttached else [volumesAttached] },
  '#withVolumesInUse': d.fn(help='List of attachable volumes in use (mounted) by the node.', args=[d.arg(name='volumesInUse', type=d.T.array)]),
  withVolumesInUse(volumesInUse): { volumesInUse: if std.isArray(v=volumesInUse) then volumesInUse else [volumesInUse] },
  '#withVolumesInUseMixin': d.fn(help='List of attachable volumes in use (mounted) by the node.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumesInUse', type=d.T.array)]),
  withVolumesInUseMixin(volumesInUse): { volumesInUse+: if std.isArray(v=volumesInUse) then volumesInUse else [volumesInUse] },
  '#mixin': 'ignore',
  mixin: self
}